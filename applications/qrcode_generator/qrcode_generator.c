#include "qrencode/qrcodegen.h"
#include <furi.h>
#include <gui/gui.h>
#include <gui/elements.h>
#include <gui/modules/text_input.h>
#include "qrcode_renderer.h"

#include <gui/modules/submenu.h>
#include <gui/modules/text_box.h>
#include <gui/modules/widget.h>
#include <gui/scene_manager.h>
#include <gui/view_dispatcher.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_TEXT_LEN 100
#define INPUT_BUFFER_SIZE 32

/* generated by fbt from .png files in images folder */
#include <qrcode_generator_icons.h>

// Diffrent app scenes
typedef enum {
	main_menu_scene,
	qrcode_input_scene,
	qrcode_message_scene,
	readme_scene,
} qrcode_scene;

// View references
typedef enum {
	qrcode_submenu_view,
	qrcode_text_input_view,
	qrcode_text_box_view,
} qrcodeView;

// App object
typedef struct App {
	SceneManager* scene_manager;
	ViewDispatcher *view_dispatcher;
	Submenu* submenu;
	TextInput* text_input;
	TextBox* text_box;
	char* qrcode_text;
	uint8_t qrcode_text_size;
} App;

// Refence to item menus. Avoid magic numbers
typedef enum {
  main_menu_scene_qrcode,
  main_menu_scene_readme,
} MainMenuSceneIndex;

// Reference to custom events. Avoid magic numbers
typedef enum {
  main_menu_scene_qrcode_event,
  main_menu_scene_readme_event,
} QrcodeMainMenuEvent;

typedef enum {
  qrcode_input_scene_save_event,
} QrcodeCipherInputEvent;


// This function is called when a custom event happens
// This event can be triggered when some pin is connected, a timer, etc
static bool basic_scene_custom_callback(void *context, uint32_t custom_event) {
	furi_assert(context);
	App *app = context;
	return scene_manager_handle_custom_event(app->scene_manager, custom_event);
}


// Function for stub menu
void qrcode_menu_callback(void *context, uint32_t index) {
	App *app = context;
	switch (index) {
		case main_menu_scene_readme:
			scene_manager_handle_custom_event(app->scene_manager,
					main_menu_scene_readme_event);
			break;
		case main_menu_scene_qrcode:
			scene_manager_handle_custom_event(app->scene_manager,
					main_menu_scene_qrcode_event);
			break;
	}
}

// Functions for every scene
// Every scene must have on_enter, on_event and on_exit
void qrcode_main_menu_scene_on_enter(void *context) {
	App *app = context;
	submenu_reset(app->submenu);
	submenu_set_header(app->submenu, "QRCode Generator");
	submenu_add_item(app->submenu, "Generate",
			main_menu_scene_qrcode, qrcode_menu_callback, app);
	submenu_add_item(app->submenu, "README", main_menu_scene_readme,
			qrcode_menu_callback, app);
	view_dispatcher_switch_to_view(app->view_dispatcher, qrcode_submenu_view);
}

bool qrcode_main_menu_scene_on_event(void *context, SceneManagerEvent event) {
	App *app = context;
	bool consumed = false;
	switch (event.type) {
		case SceneManagerEventTypeCustom:
			switch (event.event) {
				case main_menu_scene_readme_event:
					scene_manager_next_scene(app->scene_manager, readme_scene);
					consumed = true;
					break;
				case main_menu_scene_qrcode_event:
					scene_manager_next_scene(app->scene_manager, qrcode_input_scene);
					consumed = true;
					break;
			}
			break;
		default:
			break;
	}
	return consumed;
}

void main_menu_scene_on_exit(void *context) {
	App *app = context;
	submenu_reset(app->submenu);
}

void text_input_callback(void *context) {
	App *app = context;
	scene_manager_handle_custom_event(app->scene_manager,
			qrcode_input_scene_save_event);
}

void qrcode_input_scene_on_enter(void *context) {
  App *app = context;
  bool clear_text = true;
  text_input_reset(app->text_input);
  text_input_set_header_text(app->text_input, "Enter text for QRCode");
  text_input_set_result_callback(app->text_input, text_input_callback, app,
                                 app->qrcode_text, app->qrcode_text_size,
                                 clear_text);
  view_dispatcher_switch_to_view(app->view_dispatcher, qrcode_text_input_view);
}


bool qrcode_greeting_input_scene_on_event(void *context,
		SceneManagerEvent event) {
	App *app = context;
	bool consumed = false;
	if (event.type == SceneManagerEventTypeCustom) {
		if (event.event == qrcode_input_scene_save_event) {
			scene_manager_next_scene(app->scene_manager, qrcode_message_scene);
			consumed = true;
		}
	}
	return consumed;
}
void qrcode_greeting_input_scene_on_exit(void *context) { UNUSED(context); }

void generate_qrcode_on_enter(void *context) {
  App *app = context;
  text_box_reset(app->text_box);
  text_box_set_text(app->text_box, app->qrcode_text);
  view_dispatcher_switch_to_view(app->view_dispatcher, qrcode_text_box_view);
}

bool qrcode_greeting_message_scene_on_event(void *context,
                                           SceneManagerEvent event) {
  UNUSED(context);
  UNUSED(event);
  return false; // event not handled.
}
void qrcode_greeting_message_scene_on_exit(void *context) {
 	UNUSED(context); 
	//App *app = context;
    //widget_reset(app->widget);
}

void readme_scene_on_enter(void *context) {
  App *app = context;
  text_box_reset(app->text_box);
  text_box_set_text(
      app->text_box,
      "QRCode Generator is a simple generator for QRCodes."
      "github.com/qw3rtty/flipperzero_qrcode_gen");
  view_dispatcher_switch_to_view(app->view_dispatcher, qrcode_text_box_view);
}

bool readme_scene_on_event(void *context, SceneManagerEvent event) {
  UNUSED(context);
  UNUSED(event);
  return false; // event not handled.
}

void readme_scene_on_exit(void *context) {
  App *app = context;
  submenu_reset(app->submenu);
}

// Arrays for the handlers
void (*const qrcode_scene_on_enter_handlers[])(void *) = {
    qrcode_main_menu_scene_on_enter,
    qrcode_input_scene_on_enter,
    generate_qrcode_on_enter,
    readme_scene_on_enter,
};

bool (*const qrcode_scene_on_event_handlers[])(void *, SceneManagerEvent) = {
    qrcode_main_menu_scene_on_event,
    qrcode_greeting_input_scene_on_event,
    qrcode_greeting_message_scene_on_event,
    readme_scene_on_event,
};

void (*const qrcode_scene_on_exit_handlers[])(void *) = {
    main_menu_scene_on_exit,
    qrcode_greeting_input_scene_on_exit,
    qrcode_greeting_message_scene_on_exit,
    readme_scene_on_exit,
};

static const SceneManagerHandlers qrcode_scene_manager_handlers = {
    .on_enter_handlers = qrcode_scene_on_enter_handlers,
    .on_event_handlers = qrcode_scene_on_event_handlers,
    .on_exit_handlers = qrcode_scene_on_exit_handlers,
};



// Alloc for our app
// Here we are allocate the memory for our app
static App* app_alloc() {
    App* app = malloc(sizeof(App));
    app->qrcode_text_size = 128;
    app->qrcode_text = malloc(app->qrcode_text_size);
   
    app->scene_manager = scene_manager_alloc(&qrcode_scene_manager_handlers, app);

    app->view_dispatcher = view_dispatcher_alloc();
	view_dispatcher_set_event_callback_context(app->view_dispatcher, app);
	view_dispatcher_set_custom_event_callback(app->view_dispatcher, 
			basic_scene_custom_callback);

    app->submenu = submenu_alloc();
    view_dispatcher_add_view(app->view_dispatcher, qrcode_submenu_view,
            submenu_get_view(app->submenu));

    app->text_input = text_input_alloc();
    view_dispatcher_add_view(app->view_dispatcher, qrcode_text_input_view,
            text_input_get_view(app->text_input));

    app->text_box = text_box_alloc();
    view_dispatcher_add_view(app->view_dispatcher, qrcode_text_box_view,
            text_box_get_view(app->text_box));

    return app;
}

// Free the memory of the app
static void app_free(App* app) {
    furi_assert(app);

    view_dispatcher_remove_view(app->view_dispatcher, qrcode_text_input_view);
    view_dispatcher_remove_view(app->view_dispatcher, qrcode_text_box_view);
    view_dispatcher_free(app->view_dispatcher);

    scene_manager_free(app->scene_manager);
    submenu_free(app->submenu);

    text_input_free(app->text_input);
    text_box_free(app->text_box);

    free(app);
}








static void generate_and_print_qrcode(Canvas* canvas, const char* text) {
	enum qrcodegen_Ecc errCorLvl = qrcodegen_Ecc_LOW;

	// Make and print the QR Code symbol
	uint8_t qrcode[qrcodegen_BUFFER_LEN_MAX];
	uint8_t tempBuffer[qrcodegen_BUFFER_LEN_MAX];
	qrcodegen_encodeText(text, tempBuffer, qrcode, errCorLvl,
			qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX, qrcodegen_Mask_AUTO, true);

    render_qrcode(canvas, qrcode);
}

void draw_callback (Canvas* const canvas,  void* ctx) {
    furi_assert(canvas);
    furi_assert(ctx);

	const char* text = "Hello, world!";
    generate_and_print_qrcode(canvas, text);
}

int32_t qrcode_generator_app(void* p) {
	UNUSED(p);

    App* app = app_alloc();

	Gui* gui = furi_record_open("gui");
    view_dispatcher_attach_to_gui(app->view_dispatcher, gui,
            ViewDispatcherTypeFullscreen);
    scene_manager_next_scene(app->scene_manager, qrcode_message_scene);
    view_dispatcher_run(app->view_dispatcher);

    app_free(app);

    return 0;
}
